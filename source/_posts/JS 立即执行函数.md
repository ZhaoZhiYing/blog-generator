---
layout: JS 立即执行函数
title: toString
date: 2018-02-19 12:54:59
tags:
---

#### 执行环境和作用域

##### 执行环境
* `执行环境`定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
* 每个`执行环境`都有一个与之关联的`变量对象`，环境中定义的所有变量和函数都保存在这个对象中。

##### 作用域
* 当代码在一个`执行环境`中时，会创建`变量对象`的一个`作用域链`。
* `作用域链`的用途是保证对`执行环境`有权访问的所有变量和函数的有序访问。

* `作用域`分为**`全局作用域`**和**`局部作用域`(也叫函数作用域)**

* `全局作用域`中声明的变量是`全局变量`，`函数作用域`中声明的变量是`局部变量`。
* 外部无法读取 `局部变量`，但函数内部可以读取 `全局变量`。同名的`局部变量`会在函数内部覆盖 `全局变量`。  

```
var name = 'zhao'
function foo(){
	var name = 'tang'
	console.log(name)
}
foo()//tang

//函数 foo 内部的变量 name 覆盖了全局变量 name
```


##### 堆栈`Call Stack`先入后出
* 每个函数都有自己的`执行环境`。`执行环境`是用环境栈来管理的。
* 最底层的是`全局执行环境`（在浏览器中，指`Window对象`），当执行到一个函数，函数的`执行环境`就会被推入到`环境栈`中。如果在函数中继续执行函数，那么内部函数的`执行环境`就继续被推入`环境栈`。

```
function a(){
	console.log('a')
	return a
}
a.call() 
	
* 当调用时，a.call() 会被记在 call stack 里。
* 接着 console.log('a') 记在 call stack 里。
* return a 到这一步时 console.log('a') 会存在 a.call() 里，最后 a.call() 退出。
```

---

#### 立即执行函数



1. 全局变量会造成同名覆盖的问题。解决办法：声明局部变量。

2. ES6 之前，只有函数才有局部变量。

3. 于是我们声明一个 function xxx，然后 xxx.call()，但是这个时候 xxx 是全局变量（全局函数）

4. 所以我们不能给这个函数名字，使用匿名函数 function(){}.call() 

5. 使用 function(){}.call() 时候 Chrome 会报错（语法错误）

6. 于是试出来一种方法可以不报错。

```
!function(){}.call()
//!会改变函数的返回值。
```

7. 立即执行函数使得`函数内部变量`无法被外部访问

8. 闭包使得匿名函数可以操作`函数内部变量`。`window.函数名` 保存了匿名函数的地址，任何地方都可以使用 `window.函数名` 操作 `函数内部变量`，但是不能直接访问`函数内部变量`。