---
title: 排序算法
date: 2018-03-27 19:13:40
categories: 其他
tags:
---

#### 冒泡排序
	
	* 每次比较两个相邻的元素，如果他们的顺序错误就交换位置（从小到大或从大到小）。
	* 每一轮排序将一个数归位，如果有 n 个数，只需将 n-1 个数归位。
	* 每一轮排序都需要从第 1 位开始进行相邻两个数的比较，直到最后一个尚未归位的数。

`JS`代码实现

	//将 obj 里的数从小到大排列。
	var arr = [21, 30, 10, 56, 7, 39]
	
	function sort(){
	
		//定义循环排序的轮数
		for(var i=0; i<arr.length; i++){
		
			//定义当前循环轮数需要比较第几位的最大值
			//比如第 2 轮，最多比较到第 3 位和后面的数
			for(var j=0; j<=arr.length-i; j++){
			
				//前一位与后一位与前一位比较
				if(arr[j] > arr[j+1]){
					var temp = arr[j]
					arr[j] = arr[j+1]
					arr[j+1] = temp
				}
			}
		}
		return arr
	}
	
	sort(arr) //[7, 10, 21, 30, 39, 56]


---

#### 选择排序

	* 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
	* 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
	* 每一轮排序将一个数归位，如果有 n 个数，只需将 n-1 个数归位。

`JS`代码实现

	//将 obj 里的数从小到大排列。
	var arr = [21, 30, 10, 56, 7, 39]
	
	function sort(){
	
		//定义循环排序的轮数
		for(var i=0; i<arr.length; i++){
			//定义 min 变量用于存储每一轮循环最小数的下标
			var min = i 
			for(var j=i+1; j<arr.length; j++){
				if(arr[min] > arr[j]){
					min = j
				}
			}
			//每轮比较后如果arr[i]不是最小的那个数，则进行交换。
			if(min != i){
				var temp = arr[i]
				arr[i] = arr[min]
				arr[min] = temp
			}
		}
		return arr
	}
	
	sort(arr) //[7, 10, 21, 30, 39, 56]


---

#### 快速排序

	* 以一个数为基准，比这个数小的放前面，大的放后面。
	* 递归地把小于基准值的数列和大于基准值的数列进行排序。
	* 每次的迭代中，至少会把一个元素摆到它最后的位置去。

---

#### 插入排序

	* 将一组数据分成两组，分别为有序组与待插入组。
	* 每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。
	* 每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。

---

#### 计数排序

	* 找出待排序的数组中最大和最小的元素
	* 统计数组中每个值为 i 的元素出现的次数，存入数组 arr 的第 i 项
	* 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）
	* 反向填充目标数组：将每个元素 i 放在新数组的第 arr[i] 项，每放一个元素就将 arr[i] 减去 1 

---

#### 基数排序

	* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
	* 然后，从最低位开始，依次进行一次排序。
	* 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
	* 将要排序的元素分配至 0~9 个桶中

---

#### 桶排序

	* 将待排序的一组数统一分布在一个范围中，并将这一范围划分成几个子范围，也就是桶。
	* 将这一组数，分档规入这些子桶，并将桶中的数据进行排序。
	* 将各个桶中的数据有序的合并起来。

---
